# This Python file uses the following encoding: utf-8
"""
My own improved SMC sampler algorithm as described in the abstract. 
This is an improvement upon algorithm 3, implemented in AdamAndArnaudsAlgorithm3.py and described in 
[1]	A. M. Johansen, A. Doucet, and M. Davy. 
Maximum likelihood parameter estimation for maximum likelihood models using sequential Monte Carlo.
In Proceedings of ICASSP, 2006.

The difference is that my algorithm uses a MCMC kernel with static distribution defined on 
all outcomes sampled at the previous iteration, while Adam & Arnauds sampler only defines the 
MCMC sampler on all fully faded in outcomes at the previous timestep (that is, it includes 
outcomes that were sampled using importance sampling with previous_nu_t != 1.0 )

As a result, only when an integer boundary is crossed will my sampler use importance sampling to 
sample the new outcome. A&A's sampler on the other hand will always use importance sampling for 
the last outcome. Which results in way higher variance of the importance weights.
"""

from __future__ import division
from scipy import *
from particles import *
import Schedules
from GenericSMCSamplerParticleState import *
from GenericSMCSampler import *


class Improved_AandA_Algorithm3ParticleState(GenericSMCSamplerParticleState):	
	def __init__(self, design):
		GenericSMCSamplerParticleState.__init__(self,design)
								
	def evaluateLastUtilityComponent(self, marginalLikelihood, utilityFactor, nu_t):
		return utilityFactor ** nu_t
	
class Improved_AandA_Algorithm3 (GenericSMCSampler):

	ParticleType = Improved_AandA_Algorithm3ParticleState

	def __init__(self):
		GenericSMCSampler.__init__(self)
				
	def getMCMCStaticDistributionParameters(self, n_t, nu_t, previous_n_t, previous_nu_t):
		if n_t == previous_n_t:
			# MCMC kernel is defined with invariant distribution pi_{n_t, nu_t}
			return (n_t, nu_t)
		else:
			assert n_t == previous_n_t + 1
			assert previous_nu_t == 1.0
			return (previous_n_t, 1.0)

	def computePreMCMCStepIncrementalWeight(self, particle, n_t, nu_t, previous_n_t, previous_nu_t):
		
		if n_t == previous_n_t:
			return particle.utilityFactors[n_t - 1] ** (nu_t - previous_nu_t)
		else:
			assert n_t == previous_n_t + 1
			assert previous_nu_t == 1.0
			#return particle.utilityFactors[previous_n_t - 1] ** (1.0 - previous_nu_t)
			return 1.0
	
if __name__ == '__main__':
	saveName = "improvedAandA_samples.pydata"
	numParticles = 100
	numIterations = 200
	stepsPerInt = 4
	sampler = Improved_AandA_Algorithm3()
	schedule = Schedules.LinearFractionalSchedule(stepsPerInt)
	sampler.runSampler(numParticles, numIterations, schedule)
	sampler.saveSamples(saveName)



